<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL - Rotating Cube</title>
    <style>
        body { margin: 0; background-color: #eee; }
        canvas { display: block; width: 600px; height: 400px; }
    </style>
</head>
<body>
    <canvas></canvas>
    <script>
    'use strict';

    // Get the canvas element and initialize WebGL2 context
    const canvas = document.querySelector('canvas');
    let gl = canvas.getContext('webgl2');

    // Fallback to WebGL1 if WebGL2 is not supported
    if (!gl) {
        console.warn('WebGL2 not supported, falling back on WebGL1');
        gl = canvas.getContext('webgl');
    }

    // Set the canvas resolution to match the displayed size
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;

    // Set the viewport to match the canvas size
    gl.viewport(0, 0, canvas.width, canvas.height);

    // Set the clear color for the canvas (dark gray in this case) and clear the color buffer
    gl.clearColor(0.2, 0.2, 0.2, 1.0); // Set clear color to #333
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Vertex shader source code
    const vsGLSL = `#version 300 es
    in vec4 position;
    in vec4 color;
    out vec4 vColor;
    void main() {
        gl_Position = position;
        vColor = color;
    }
    `;

    // Fragment shader source code
    const fsGLSL = `#version 300 es
    precision highp float;
    in vec4 vColor;
    out vec4 outColor;
    void main() {
        outColor = vColor;
    }
    `;

    // Create and compile the vertex shader
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsGLSL);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(vertexShader));
    }

    // Create and compile the fragment shader
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsGLSL);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(fragmentShader));
    }

    // Create a WebGL program and attach both shaders to it
    const prg = gl.createProgram();
    gl.attachShader(prg, vertexShader);
    gl.attachShader(prg, fragmentShader);
    gl.linkProgram(prg);
    if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prg));
    }

    // Get the location of the 'position' and 'color' attributes in the shader program
    const positionLoc = gl.getAttribLocation(prg, 'position');
    const colorLoc = gl.getAttribLocation(prg, 'color');

    // Define the vertex positions and single color for the cube
    const vertexData = new Float32Array([
        // x, y, z       Color (R, G, B, A)
        0, 0, 0,    1, 0, 0, 1, // Red color
        1, 0, 0,    1, 0, 0, 1, // Red color
        0, 1, 0,    1, 0, 0, 1, // Red color
        1, 1, 0,    1, 0, 0, 1, // Red color
        0, 0, 1,    1, 0, 0, 1, // Red color
        1, 0, 1,    1, 0, 0, 1, // Red color
        0, 1, 1,    1, 0, 0, 1, // Red color
        1, 1, 1,    1, 0, 0, 1, // Red color
    ]);

    const indices = new Uint16Array([
        0, 1, 2, 1, 3, 2,  // Front face
        4, 5, 6, 4, 6, 7, // Back face
        0, 4, 7, 0, 7, 3, // Left face
        1, 5, 6, 1, 6, 2, // Right face
        3, 2, 6, 3, 6, 7, // Top face
        0, 1, 5, 0, 5, 4  // Bottom face
    ]);

    // Create a Vertex Array Object (VAO) to store state related to vertex input
    const VAO = gl.createVertexArray();
    gl.bindVertexArray(VAO);

    // Create a buffer and bind it to the ARRAY_BUFFER target
    const VBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

    // Enable the 'position' attribute and describe its layout in the buffer
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(
        positionLoc, 3, gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0
    );

    // Enable the 'color' attribute and describe its layout in the buffer
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(
        colorLoc, 4, gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT
    );

    const EBO = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Use the shader program
    gl.useProgram(prg);

    // Get uniform location for model-view-projection matrix
    const mvpLoc = gl.getUniformLocation(prg, 'modelViewProjection');

    let angle = 0;
    const render = () => {
        angle += 0.01;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const modelViewProjection = new Float32Array([
            cos, 0, sin, 0,
            0, 1, 0, 0,
            -sin, 0, cos, 0,
            0, 0, -5, 1
        ]);

        // Pass rotation matrix to shader
        gl.uniformMatrix4fv(mvpLoc, false, modelViewProjection);

        // Clear and draw the cube
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        gl.bindVertexArray(VAO);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(render);
    };

    requestAnimationFrame(render);
    </script>
</body>
</html>
